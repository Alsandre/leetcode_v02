// ერთ სტრიქონში პერიმეტრის პოვნა რთული არ არის
// თუმცა როდესაც ორ სტრიქონს ვაერთებთ მათ აქვთ საერთო საზღვარი
// რომელიც ანულირდება?
// თუ ვიპოვით თითოეულ თანაკვეთას
// და გვეცოდინება 1 ების რაოდენობა
// შეგვიძლია კუნძულის პერიმეტრის დათვლა

// 1 ების რაოდენობის დათვლა რთული არ არის
// თანაკვეთის საპოვნელად უნდა დავაფიქსიროთ თითოეული სტრიქონში 1 ების ინდექსი
// თუ მეზობელ სტრიქონში იგივე ინდექსზე გვაქვს 1 ესეიგი გვაქვს თანაკვეთა
// ყოველი თანაკვეთი აბათილებს 2 ერთეულს პარამეტრის ჯამიდან

// რატომღაც მგონია რომ ობიექტად წარმოდგენა მოცემული ცხრილის
// გაამარტივებს საქმეს
// თუმცა ჯერ ვცდი მოცემული მასივის გამოყენებით

// ალგორითმი:
// ნაბიჯი 1 - შევქმნათ ცვლადი კვადრატების რაოდენობის დასათვლელად ones
// ნაბიჯი 2 - შევქმნათ ცვლადი თანაკვეთების დასათვლელად commEdge
// ნაბიჯი 3 - შევქმნათ ციკლი სვეტებისთვის
// ნაბიჯი 4 - შევქმნათ დროებითი ცვლადი 1 ების დასათვლელად tempOnes
// ნაბიჯი 5 - შევქმნათ ცვლადი სტრიქონებისთვის
// ნაბიჯი 6 - გამოვიძახოთ თითოეული ელემენტი
// ნაბიჯი 7 - თუ მისი მნიშვნელობა 1, მაშინ გავზარდოთ ones და გავზარდოთ tempOnes
// ნაბიჯი 9 - თუ არსებობს წინა სტრიქონი, და მასში ამჟამინდელ ინდექსზე გვაქვს 1, მაშინ commEdge გავზარდოთ ერთით
// ნაბიჯი 10 - მეორე ციკლის დასრულებისას, სანამ პირველი ციკლის შემდეგ იტერაციაზე გადავალთ, commEdge გავზარდოთ tempOnes-1 ით და ჩამოვყაროთ დროებითი ვცლადის მნიშვნელობა
// ნაბიჯი 11 - ones გავამრავლოთ 4-ზე და გამოვაკლოთ commEdge გამრავლებული 2-ზე

function islandPerimeter(grid: number[][]): number {
  let ones = 0,
    commEdge = 0;

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      let curr = grid[i][j];
      if (curr === 1) {
        ones++;
        if (grid[i - 1] && grid[i - 1][j] === 1) {
          commEdge++;
        }
        if (grid[i][j - 1] && grid[i][j - 1] === 1) {
          commEdge++;
        }
      }
    }
  }
  return ones * 4 - commEdge * 2;
}
