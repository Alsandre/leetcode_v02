// პირველ რიგში შევნიშნოთ, რომ თუ გადმოცემული მატრიცა და გადმოცემული პარამეტრები არათავსებადია
// ვაბრუნებთ გადმოცემულ მატრიცას შეუცვლელად
// სხვა შემთხვევაში მიღებული პარამეტრებით ვქმნით ორ განზომილებიან მასივს და ვწურავთ მასში გადმოცემულ მატრიცას

// ჩაწურვის ორი მეთოდი მაფიქრდება
// პირველი მასივზე იტერაციით, ციკლები შევქმნათ უშუალოდ მასივების ზომების შესაბამისად
// მეორე ელემენტების საერთო რაოდენობისა და მიმართული ცვლადების გამოყენებით
// რადგან ელემენტების სრული რაოდენობა ცნობილია, შესაძლებელი უნდა იყოს ამ რაოდენობის იტერაციით
// სასურველი შედეგის მიღება

// ალგორითმი:
// ნაბიჯი 1 - თუ გადმოცემული მატრიცა და გადმოცემული პარამეტრები არათავსებადია, მაშინ დავაბრუნოთ გადმოცემული მატრიცა
// ნაბიჯი 2 - შევქმნათ ორ განზომილებიანი მასივი answer მიღებული პარამეტრების შესაბამისად
// ნაბიჯი 3 - შევქმნათ ცვლადები origCol, origRow, newCol და newRow და მივცეთ მათ მნიშვნელობა 0
// ნაბიჯი 4 - შევქმნათ ციკლი ელემენტთა საერთო რაოდენობის შესაბამისად
// ნაბიჯი 5 - სანამ [origCol][origRow] ვალიდური ელემენტია და [newCol][newRow] ცარიელი ადგილი
// ნაბიჯი 6 - ჩავწეროთ [newCol][newRow] ზე [origCol][origRow]
// ნაბიჯი 7 - მიმართული ცვლადები ვაკონტროლოთ და განვააახლოთ თ გახდება არავალიდური
// ნაბიჯი 8 - დავაბრუნოთ answer როგორც ფუნქციის შედეგი

function matrixReshape(mat: number[][], r: number, c: number): number[][] {
    let origCols = mat[0].length;
    let origRows = mat.length;
    console.log(origRows, origCols);
  
    if (origCols * origRows !== c * r) return mat;
  
    let answer = Array.from({ length: r }, () => Array(c).fill(0));
    for (let i = 0; i < r * c; i++) {
      let origRow = Math.floor(i / origCols);
      let origCol = i % origCols;
      // console.log('old',origRow, origCol);
  
      let newRow = Math.floor(i / c);
      let newCol = i % c;
      answer[newRow][newCol] = mat[origRow][origCol];
    }
    return answer;
  }
  
  let ans = matrixReshape(
    [
      [1, 2],
      [3, 4],
    ],
    4,
    1
  );
  
  console.log(ans)