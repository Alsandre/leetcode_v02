// გვჭირდება ვიპოვოთ ინდექსები იმ ელემენტებისა რომლებიც გვხვდება ორივე მასივში
// შემდგომ ამ ინდექსების წყვილებს შორის მინიმალური მნიშვნელობა უნდა მოვძებნოთ
// საბოლოოდ დავაბრუნოთ ის ელემენტი ან ელემენტები რომლებიც შეესაბამებიან მინიმალურ მნიშვნელობას
// დავალების შესასრულებლად მოსახერხებელია გამოვიყონოთ ობიექტი აღრიცხვის საწარმოებლად
// ობიექტის გასაღები იქნება ის ელემენტი რომელიც ორივე მასივშია წარმოდგენილი
// ხოლო მის მნიშვნელობად შეგვიძლია პირდაპირ ინდექსების ჯამი მივუთითოთ

// ალგორითმი:
// ნაბიჯი 1 - შევქმნათ ობიექტი list1ToMap და შევინახოთ მასში ობიექტად გარდაქმნილი პირველი მასივი
// ნაბიჯი 2 - შევქმნათ ცვლადი minSum და გავუტოლოთ პირველი მასივის ზომას
// ნაბიჯი 3 - შევქმნათ ობიექტი commonTerms
// ნაბიჯი 4 - შევქმნათ ციკლი მეორე მასივის ელემენტების გამოსაძახებლად
// ნაბიჯი 5 - თითოეული ელემენტისთვის რომელიც ასევე იძებნება list1ToMap რუკაში
// ნაბიჯი 6 - თუ მოცემული სტრინგის ინდექსების ჯამი უკვე არსებობს commonTerms ობიექტში მაშინ დავამატოთ იგი მასში
// ნაბიჯი 7 - სხვა შემთხვევაში შევქმნათ ახალი გასაღები commonTerms ობიექტში და გავუტოლოთ იგი მასივში მოქცეული ამჟამინდელი ელემენტის მნიშვნელობას
// ნაბიჯი 8 - თუ ეს ჯამი უფრო ნაკლებია ვიდრე minSum ამჟამინდელი მნიშვნელობა მაშინ გავუტოლოთ minSum მნიშვნელობა ჯამს
// ნაბიჯი 9 - დავაბრუნოთ commonTerms ობიექტიდან ის მასივი რომელიც შენახულია minSum გასაღებზე

function findRestaurant(list1: string[], list2: string[]): string[] {
  let list1ToMap = list1.reduce(
    (acc, val, ind) => ({ ...acc, [val]: ind }),
    {}
  );
  let minSum = list1.length;
  let commonTerms: { [key: number]: string[] } = {};
  for (let i = 0; i < list2.length; i++) {
    if (list1ToMap[list2[i]]) {
      let indSum = list1ToMap[list2[i]] + i;
      if (commonTerms[indSum]) commonTerms[indSum].push(list2[i]);
      else commonTerms[indSum] = [list2[i]];
      minSum = Math.min(minSum, indSum);
    }
  }
  return commonTerms[minSum];
}
