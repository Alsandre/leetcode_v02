// ორობითი ძებნის ალგორითმი "დაყავი და დაიპყარი" ტიპის ალგორითმების კატეგორიაში გვხვდება
// მის განსახორციელებლად აუცილებელი მოთხოვნაა რომ მიღებული მონაცემები უნდა იყოს დალაგებული
// ალგორითმის პრინციპი შემდეგია: მიღებული სიიდან ვირჩევთ შუა პოზიციაზე მდგომ ელემენტს
// თუ ეს ელემენტი ჩვენი ძებნის მიზანი არ არის მაშინ განვსაზღვრავთ უნდა გავაგრძელოთ ძებნა მასე მნიშვნელობით მეტი თუ ნაკლები ელემენტების სიმრავლეში
// ამ გადაწყვეტილების მისაღებად აუცილებელია ზემოთ ხსენებული პირობა რომ სია იყოს დალაგებული
// შესაბამისად ალგორითმი ყოველი გადაწყვეტილების მიღების მომენტში, თუ ეს წარუმატებელი მცდელობაა
// შემდგომი ძიებისთვის საძიებო ელემენტთა სიმრავლეს ანახევრებს
// შესაბამისად ალგორითმის კომპლექსურობა გამოისახება ფორმულით O(log n)

// ალგორითმი
// ნაბიჯი 1 - ვიპოვოთ მასივის შუა ელემენტი
// ნაბიჯი 2 - თუ შუა ელემენტი შეესაბამება საძიებო ელემენტს, მაშინ დავაბრუნოთ მისი ინდექსი
// ნაბიჯი 3 - სხვა შემთხვევაში თუ შუა ელემენტი უფრო მეტია ვიდრე საძიებო ელემენტი, გავაგრძელოთ ძებნა მარცხნივ
// ნაბიჯი 4 - თუ შუა ელემენტი უფრო ნაკლებია ვიდრე საძიებო ელემენტი, გავაგრძელოთ ძებნა მარცხნივ
// ნაბიჯი 5 - თუ ვერ ვიპოვეთ დამთხვევა დავაბრუნოთ -1

function search(nums: number[], target: number): number {
  let mid = Math.floor(nums.length / 2);
  let left = 0;
  let right = nums.length - 1;
  while (left < right) {
    if (nums[mid] === target) return mid;
    else if (nums[mid] > target) right = mid - 1;
    else left = mid + 1;
    mid = Math.floor((left + right) / 2);
  }
  return -1
}

let ans = search([-1, 0, 3, 5, 9, 12], 12);
console.log(ans);
// რეკურსიული მიდგომა, საწყისი მასივის გადაყოლების გარეშე
// რადგან მოდიფიცირებული მასივში ელემენტის ძიებისას, ამ ელემენტის პოზიციის იდენტიფიცირება საწყის მასივში რთული იქნება
