// ორობითი ძებნის ალგორითმი "დაყავი და დაიპყარი" ტიპის ალგორითმების კატეგორიაში გვხვდება
// მის განსახორციელებლად აუცილებელი მოთხოვნაა რომ მიღებული მონაცემები უნდა იყოს დალაგებული
// ალგორითმის პრინციპი შემდეგია: მიღებული სიიდან ვირჩევთ შუა პოზიციაზე მდგომ ელემენტს
// თუ ეს ელემენტი ჩვენი ძებნის მიზანი არ არის მაშინ განვსაზღვრავთ უნდა გავაგრძელოთ ძებნა მასე მნიშვნელობით მეტი თუ ნაკლები ელემენტების სიმრავლეში
// ამ გადაწყვეტილების მისაღებად აუცილებელია ზემოთ ხსენებული პირობა რომ სია იყოს დალაგებული
// შესაბამისად ალგორითმი ყოველი გადაწყვეტილების მიღების მომენტში, თუ ეს წარუმატებელი მცდელობაა
// შემდგომი ძიებისთვის საძიებო ელემენტთა სიმრავლეს ანახევრებს
// შესაბამისად ალგორითმის კომპლექსურობა გამოისახება ფორმულით O(log n)

// ალგორითმი
// ნაბიჯი 1 - ვიპოვოთ მასივის შუა ელემენტი
// ნაბიჯი 2 - თუ შუა ელემენტი შეესაბამება საძიებო ელემენტს, მაშინ დავაბრუნოთ მისი ინდექსი
// ნაბიჯი 3 - სხვა შემთხვევაში თუ შუა ელემენტი უფრო მეტია ვიდრე საძიებო ელემენტი, გავაგრძელოთ ძებნა მარცხნივ
// ნაბიჯი 4 - თუ შუა ელემენტი უფრო ნაკლებია ვიდრე საძიებო ელემენტი, გავაგრძელოთ ძებნა მარცხნივ
// ნაბიჯი 5 - თუ ვერ ვიპოვეთ დამთხვევა დავაბრუნოთ -1

function search(nums: number[], target: number): number {
  let mid = Math.floor(nums.length / 2);
  if (nums[mid] === target) return mid;
  if (nums[mid] > target) {
    let left = nums.slice(0, mid);
    search(left, target);
  } else {
    let right = nums.slice(mid, nums.length);
    search(right, target);
  }

  return -1;
}

search([-1, 0, 3, 5, 9, 12], 9);
