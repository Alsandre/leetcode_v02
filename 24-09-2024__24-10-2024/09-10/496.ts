// მომდევნო უმეტესი ელემენტის განმარტების პერეფრაზი:
// უნდა იყოს მნიშვნელობითაც და ინდექსითაც უფრო მაღალი

// მოცემული ორი მასივიდან ერთი ეკუთვნის მეორეს, თუმცა არცერთი მასივში არ არის განსაზღვრული თანმიმდევრობა

// მცირე მასივის ყოველი ელემენტისთვის უნდა ვიპოვოთ შემდეგი მონაცემი:
// უმეტესი ელემენტი დიდი მასივიდან, ან თუ ესეთი ელემენტი არ არსებობს -1

// ფუნქცია უნდა გამოიტანოს მიღებული მონაცემების მასივი

// ვფიქრობ რომ ორი მიმართულებით შეიძლება წასვლა
// პირველი: თითოეული საძიებო ელემენტისთვის იტერაციულად გავიაროთ სამიზნე მასივი
// მეორე: სამიზნე მასივი ვაქციოდ ძიებისთვის მოსახერხებელ მონაცემთა სტრუქტურად

// პირველ მიდგომას ვუწოდებდი პირდაპირ გადაჭრას (brute force), რომლის მუშაობის ეფექტურობა
// იქნება დაბალი რადგან მოგვიწევს ჩანერგილი ციკლების გამოყენება

// ხოლო იდეურად მეორე მიდგომა უნდა იყოს შედარებით ოპტიმალური დროისა და მეხსიერების
// გამოყენების თვალსაზრისით, თუმცა რადგან არსებული თანმიმდევრობა მნიშვნელოვანია, შესაძლოა რომ
// მონაცემების სტრუქტურის შეცვლამ პირიქით გაართულოს ძებნის პროცესი

// ალგორითმი, პირდაპირი გადაჭრა:

// ნაბიჯი 1 - შევქმნათ ცარიელი მასივი result მოძიებული მონაცემების შესანახად
// ნაბიჯი 2 - შევქმნათ ციკლი მცირე მასივის თითოეული ელემენტის გამოსაძახებლად
// ნაბიჯი 3 - შევქმნათ დროებითი ცვლადი searchRes ძიების შედეგის შესანახად და მივანიჭოთ მნიშვნელობა -1
// ნაბიჯი 4 - ვიპოვოთ სამიზნე მასივში საძიებო ელემენტის ინდექსი და შევინახოთ მნიშვნელობა startInd ცვლადში
// ნაბიჯი 5 - შევქმნათ ციკლი სამიზნე მასივისთვის დაწყებული startInd ინდექსიდან
// ნაბიჯი 6 - სამიზნე მასივის თითოეული ელემენტი შევადაროთ მცირე მასივის ამჟამინდელ ელემნტს
// ნაბიჯი 7 - თუ სამიზნე მასივის ელემენტის მნიშვნელობა უფრო მაღალია, მაშინ განვაახლოთ searchRes მნიშვნელობა და შევწყვიტოთ სამიზნე მასივზე იტერაცია
// ნაბიჯი 8 - დავამატოთ searchRes შედეგების მასივში result
// ნაბიჯი 9 - დავაბრუნოთ result როგორც ფუნქციის შედეგი

function _nextGreaterElement(nums1: number[], nums2: number[]): number[] {
  let result: number[] = [];
  for (let i = 0; i < nums1.length; i++) {
    let searchRes = -1;
    let startInd = nums2.indexOf(nums1[i]);
    for (let j = startInd; j < nums2.length; j++) {
      if (nums2[j] > nums1[i]) {
        searchRes = nums2[j];
        break;
      }
    }
    result.push(searchRes);
  }
  return result;
}

// საკმაოდ უცნაურია რომ ამჟამინდელი იმპლემენტაცია ეფექტურად მუშაობს 97.68% გადაჭრებზე უკეთესია
// დროითი კომპლექსურობის თვალსაზრისით

// თუმცა ვფიქრობ არსებობს ოპტიმიზაციის გზები
// მაგალითად indexOf მეთოდის დროის კომპლექსურობა არის O(n) და ჩვენ მას ვიძახებთ თითოეული ელემენტისთვის მცირე მასივში
// კონკრეტულად ამ ოპერაციის ოპტიმიზაციისთვის შეგვიძლია შევქმნათ სამიზნე მასივის რუკა
// შესაბამისად ინდექსის ძიება გახდება O(1)
// ხოლო საერთო ჯამში ალგორითმის ეს ნაწილი O(n^2) დან შემცირდება O(n) მდე

function nextGreaterElement(nums1: number[], nums2: number[]): number[] {
  let result: number[] = [];
  let nums2Hash: { [key: number]: number } = {};
  for (let i = 0; i < nums2.length; i++) {
    nums2Hash[nums2[i]] = i;
  }
  for (let i = 0; i < nums1.length; i++) {
    let searchRes = -1;
    let startInd = nums2Hash[nums1[i]];
    for (let j = startInd; j < nums2.length; j++) {
      if (nums2[j] > nums1[i]) {
        searchRes = nums2[j];
        break;
      }
    }
    result.push(searchRes);
  }
  return result;
}

// ამ მიდგომით გაუმჯობესდა მეხსიერების გამოყენების კომპლექსურობა, რაც ცოტათი უცნაურია
// თუმცა საბოლოო შედეგი დამაკმაყოფილებელია, არსებული მოთხოვნებისთვის
// ამავდროულად ვფიქრობ რომ ოპტიმიზაციისთვის რა თქმა უნდა კიდევ არსებობს სივრცე