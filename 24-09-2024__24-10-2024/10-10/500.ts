// პრობლემის ფორმალური სახე ასეთია:
// ჩვენ გვჭირდება მოვახდინოთ მიღებული ტექსტური მასივის ელემენტების შედარება სამი ტიპის კოლექციასთან
// უფრო კონკრეტულად, გადმოცემული ტექსტის პირველი წევრი განსაზღვრავს თუ რომელ კოლექციასთან მოხდება მომდევნო წევრების შედარება
// გამომდინარე პირობიდან, რადგან თუ მიღებული ტექსტის ყველა წევრი არ იყრის თავს ერთ კოლექციაში
// მაშინ ესეთი ტექსტი არა ვალიდურია.

// უნდა გავითვალისწინოთ რომ გადმოცემული ტექსტის წევრები შეიძლება შეიცავდნენ როგორც მაღალ ასევე დაბალ სიმბოლოებს
// შედარების თვალსაზრისით, მაღალი და დაბალი სიმბოლოები განსხვავებული მნიშვნელობებია, თუმცა
// მოცემული დავალებისთვის მათი მნიშვნელობა იდენტურია

// პრობლემის გადასაჭრელად შევქმნათ კოლექციები მხოლოდ დაბალი სიმბოლოების გამოყენებით
// ხოლო მიღებული შერეული სიმბოლოები, შედარებისას გარდავქმნათ დაბალ სიმბოლოდ
// ოპერაციული თვალსაზრისით, ეს მიდგომა ნაკლებად ოპტიმალურია, რადგან ამ შემთხვევაში
// დამატებით შესასრულებელი ოპერაციების რაოდენობა n უტოლდება, n არის დასამუშავებელ მონაცმებთა სრული რაოდენობა
// ხოლო თუ ჩვენ კოლექციებშივე ჩავაშენებთ მაღალ და დაბალ სიმბოლოებს, ამ შემთხვევაში
// გარდაქმნის ოპერაციების რაოდენობა დაიყვანება მუდმივ რიცხვამდა და ოპერაცია შესრულდება მხოლოდ ერთხელ კოლექციების შექმნის მომენტში

// შედარებისთვის უფრო მოსახერხებელი იქნება თუ კოლექციის მონაცემური სტრუქტურა იქნება მოსახერხებელი შემადგენელი წევრების ძიებისათვის
// ასეთი სტრუქტურას Javasript შემთხვევაში წარმოადგენს ობიექტი, რადგან ძებნის კომპლექსურობა მუდმივია
// თუმცა მეორე მხრივ მასივის აღების შემთხვევაშიც ძებნის კომპლექსურობა შემოსაზღვრული იქნება მუდმივი რიცხვით რომელიც
// კოლექციაში შემავალი ელემენტების რაოდენობაა და შესაბამისად არ იქნება ის დამოკიდებული გადმოცემული ელემენტების რაოდენობაზე

// ალგორითმი:

// ნაბიჯი 1 - შევქმნათ ცვლადი rowOne  და შევიყვანოთ მასში პირველი კოლექციის ყველა შესაძლო მნიშვნელობა
// ნაბიჯი 2 - შევქმნათ ცვლადი rowTwo  და შევიყვანოთ მასში მეორე კოლექციის ყველა შესაძლო მნიშვნელობა
// ნაბიჯი 3 - შევქმნათ ცვლადი rowThree  და შევიყვანოთ მასში მესამე კოლექციის ყველა შესაძლო მნიშვნელობა
// ნაბიჯი 4 - შევქმნათ ცარიელი მასივი result
// ნაბიჯი 5 - შევქმნათ ციკლი მიღებული მასივის წევრებისთვის
// ნაბიჯი 6 - შევქმნათ ცვლადი activeCollection
// ნაბიჯი 6 - ვიპოვოთ რომელ კოლექციაშია ელემენტის პირველი წევრი და ამ კოლექციაზე მივუთითოთ activeCollection ცვლადი
// ნაბიჯი 7 - ელემენტის დანარჩენი წევრები მოვძებნოთ აქტიურ კოლექციაში, თუ რომელიმე წევრი არ მოიძებნა, შევწყვიტოთ იტერაცია მოცემულ ელემენტზე და გადავიდეთ შემდეგზე
// ნაბიჯი 8 - თუ ელემენტის ყველა წევრი არის აქტიურ კოლექციაში, მაშინ დავამატოთ ელემენტი result მასივში
// ნაბიჯი 9 - დავაბრუნოთ result  როგორც ფუნქციის შედეგი

function findWords(words: string[]): string[] {
  let rowOne = "qwertyuiopQWERTYUIOP";
  let rowTwo = "asdfghjklASDFGHJKL";
  let rowThree = "zxcvbnmZXCVBNM";
  let result: string[] = [];

  outer: for (let i = 0; i < words.length; i++) {
    const firstChar = words[i].charAt(0);
    let activeCollection =
      (rowOne.includes(firstChar) && rowOne) ||
      (rowTwo.includes(firstChar) && rowTwo) ||
      (rowThree.includes(firstChar) && rowThree) ||
      "";
    for (let j = 1; j < words[i].length; j++) {
      if (!activeCollection.includes(words[i].charAt(j))) continue outer;
    }
    result.push(words[i]);
  }

  return result;
}

let ans = findWords(["Hello", "Alaska", "Dad", "Peace"]);
console.log(ans);
