// მოცემულია ორი მასივი
// ჩვენი მიზანია ვიპოვოთ მოცემულ მასივთა თანაკვეთა
// რაც გულისხმობს ისეთი ახალი მასივის შექმნას
// რომელშიც შემავალი თითოეული ელემენტი წარმოდგენილი იქნება თავდაპირველად მოწოდებულ ორივე მასივში
// არა მხოლოდ მნიშვნელობა, არამედ ელემენტთა სიხშირეც უნდა იყოს შესაბამისი

// ამოცანის ამოსახსნელად შესაძლებელია გამოვიყენოთ "ჰაშრუკა"
// თითოეული მასივისთვის შევქმნათ ახალი "ჰაშრუკა"
// სადაც წარმოდგენილი იქნება ელემენტები და სიხშირეები
// შემდეგი ნაბიჯი იქნება "ჰაშრუკა" გამოვიყენოთ ახალი მასივის შესაქმნელად
// გავითვალისწინოთ ელემენტის არსებობა ორივე "ჰაშრუკაში" და მათი სიხშირე

// ალგორითმი:
// მოქმედება 1 - შევქმნათ ახალი ობიექტები hashNums1 და hashNums2
// მოქმედება 2 - შევქმნათ ცარიელი მასივი result
// მოქმედება 3 - შევქმნათ იტერაციული ციკლი პირველი მასივისთვის
// მოქმედება 4 - თითოეული იტერაციისთვის შევამოწმოთ არის თუ არა შესაბამის "ჰაშრუკაში" ამჟამინდელი ელემენტი
// მოქმედება 5 - თუ ელემენტი წარმოდგენილია, მაშინ გავზარდოთ მისი სიხშირე ერთით
// მოქმედება 6 - თუ ელემენტი წარმოდგენილი არ არის, მაშინ დავამატოთ იგი "ჰაშრუკაში" და მივანიჭოთ სიხშირე 1
// მოქმედება 7 - შევქმნათ იტერაციული ციკლი მეორე მასივისთვის
// მოქმედება 8 - გავიმეოროთ 4-6 მოქმედებები შესაბამისი მნიშვნელობებისთვის
// მოქმედება 9 - შევქმნათ იტერაციული ციკლი hashNums1 ობიექტის გასაღებებისთვის
// მოქმედება 10 - თითოეული გასაღებისთვის შევამოწმოთ არის თუ არა იგივე გასაღები  hashNums2 ობიექტში
// მოქმედება 11 - თუ ელემენტი წარმოდგენილია ორივე ობიექტში მაშინ დავამატოთ იგი result მასივში ელემენტების სიხშირეებს შორის უმცირესი მნიშვნელობის შესაბამისად
// მოქმედება 12 - თუ ელემენტი წარმოდგენი არ არის რომელიმე ობიექტში მაშინ გამოვტოვოთ იტერაცია
// მოქმედება 13 - დავაბრუნოთ result მასივი

function intersect(nums1: number[], nums2: number[]): number[] {
  // მოქმედებები 1-2
  let hashNums1: { [key: number]: number } = {};
  let hashNums2: { [key: number]: number } = {};
  let result: number[] = [];

  // მოქმედება 3
  for (let element of nums1) {
    // მოქმედება 4-6
    hashNums1[element] = hashNums1[element] ? hashNums1[element] + 1 : 1;
  }

  // მოქმედება 7
  for (let element of nums2) {
    // მოქმედება 8
    hashNums2[element] = hashNums2[element] ? hashNums2[element] + 1 : 1;
  }

  // მოქმედება 9
  for (let key in hashNums1) {
    // მოქმედება 10
    if (hashNums2.hasOwnProperty(key)) {
      for (let i = 0; i < Math.min(hashNums1[key], hashNums2[key]); i++) {
        result.push(Number(key));
      }
    }
  }

  return result;
}

let nums1 = [1, 2, 2, 1],
  nums2 = [2, 2];

let res = intersect(nums1, nums2);
console.log(res);
